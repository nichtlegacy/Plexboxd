diff --git a/.gitignore b/.gitignore
index 53f1151..dca50c7 100644
--- a/.gitignore
+++ b/.gitignore
@@ -8,6 +8,8 @@ logs
 # Data directories with generated or sensitive content
 data
 
+docs
+
 # Python-specific files and directories
 __pycache__/
 *.pyc
diff --git a/requirements.txt b/requirements.txt
index 2ba4551..43f5007 100644
--- a/requirements.txt
+++ b/requirements.txt
@@ -1,5 +1,5 @@
 # Core dependencies for Discord bot
-discord.py==2.5.0
+discord.py==2.6.4
 
 # Plex integration
 plexapi==4.15.16
diff --git a/src/letterboxd_integration.py b/src/letterboxd_integration.py
index 354092d..81b1ba1 100644
--- a/src/letterboxd_integration.py
+++ b/src/letterboxd_integration.py
@@ -210,8 +210,8 @@ def get_film_id_selenium(session, film_name, film_year, original_title=None, tmd
     finally:
         driver.quit()
 
-def save_diary_entry(session, csrf_token, film_id, rating, viewing_date=None):
-    """Save a diary entry with rating and adjusted date.
+def save_diary_entry(session, csrf_token, film_id, rating, viewing_date=None, rewatch=False, liked=False, tags="", review=""):
+    """Save a diary entry with rating and optional diary fields.
     
     Args:
         session: The requests session with authentication.
@@ -219,6 +219,10 @@ def save_diary_entry(session, csrf_token, film_id, rating, viewing_date=None):
         film_id: The Letterboxd film ID.
         rating: The rating value (0.5-5.0).
         viewing_date: Optional ISO format date string.
+        rewatch: Whether this is a rewatch (default False).
+        liked: Whether the user liked the film (default False).
+        tags: Comma-separated tags string (default empty).
+        review: Review text (default empty).
     
     Raises:
         ValueError: If the diary entry fails or response is invalid.
@@ -231,7 +235,6 @@ def save_diary_entry(session, csrf_token, film_id, rating, viewing_date=None):
     else:
         viewing_date = get_adjusted_date()
 
-    """Save a diary entry with rating and adjusted date."""
     headers = {
         "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/133.0.0.0 Safari/537.36",
         "Referer": "https://letterboxd.com/",
@@ -247,14 +250,39 @@ def save_diary_entry(session, csrf_token, film_id, rating, viewing_date=None):
         "filmId": film_id,
         "specifiedDate": "true",
         "viewingDateStr": viewing_date.strftime("%Y-%m-%d"),
-        "review": "",
-        "tags": "",
+        "review": review,
+        "tags": tags,
         "rating": int(rating * 2),  # Convert to 1-10 scale
-        "liked": "false",
+        "liked": "true" if liked else "false",
+        "rewatch": "true" if rewatch else "false",
         "reviewLanguageCodeHint": "de-DE"
     }
-    logger.info(f"Saving diary entry for film ID {film_id} with rating {rating} for date {viewing_date.strftime('%Y-%m-%d')}")
-    response = session.post(DIARY_URL, data=diary_data, headers=headers)
+    
+    # Parse and add individual tags (Letterboxd expects multiple 'tag' fields)
+    if tags:
+        # Split by comma or space, strip whitespace, filter empty
+        tag_list = [t.strip() for t in tags.replace(',', ' ').split() if t.strip()]
+        for tag in tag_list:
+            # Use list to allow multiple 'tag' keys
+            if 'tag' not in diary_data:
+                diary_data['tag'] = []
+            if isinstance(diary_data.get('tag'), list):
+                diary_data['tag'].append(tag)
+            else:
+                diary_data['tag'] = [diary_data['tag'], tag]
+    
+    logger.info(f"Saving diary entry for film ID {film_id} with rating {rating}, liked={liked}, rewatch={rewatch} for date {viewing_date.strftime('%Y-%m-%d')}")
+    
+    # Convert to proper format for requests (handle multiple tag values)
+    post_data = []
+    for key, value in diary_data.items():
+        if isinstance(value, list):
+            for v in value:
+                post_data.append((key, v))
+        else:
+            post_data.append((key, value))
+    
+    response = session.post(DIARY_URL, data=post_data, headers=headers)
     
     try:
         diary_response = json.loads(response.text)
diff --git a/src/plex_bot.py b/src/plex_bot.py
index c604874..73537d8 100644
--- a/src/plex_bot.py
+++ b/src/plex_bot.py
@@ -33,10 +33,14 @@ NOTIFY_CHANNEL_ID = int(os.getenv("NOTIFY_CHANNEL_ID"))
 GUILD_ID = int(os.getenv("GUILD_ID"))
 PLEX_USERNAME = os.getenv("PLEX_USERNAME")
 EXCLUDED_LIBRARIES = [lib.strip() for lib in os.getenv("EXCLUDED_LIBRARIES", "").split(",") if lib.strip()]
+
+# Global branding constants
 PLEX_LOGO = "https://i.imgur.com/AdmDnsP.png"
 LETTERBOXD_LOGO = "https://i.imgur.com/0Yd2L4i.png"
+EMBED_AUTHOR_NAME = "Plex Movie Notification üé¨"
+EMBED_FOOTER_TEXT = "Watched"
 
-CURRENT_VERSION = "1.1.9"
+CURRENT_VERSION = "1.2.0"
 
 SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
 MOVIE_DATA_PATH = os.path.join(SCRIPT_DIR, '../data/movie_data.json')
@@ -224,6 +228,67 @@ class MovieDatabase:
         with self._get_connection() as conn:
             conn.execute('UPDATE movies SET is_rated = 1 WHERE rating_key = ?', (rating_key,))
 
+    def was_previously_watched(self, tmdb_id: str = None, title: str = None, year: int = None) -> bool:
+        """Check if a movie was previously watched/rated (for rewatch detection).
+        
+        Uses TMDB ID as primary identifier, falls back to title+year.
+        Returns True if the movie exists in DB with is_rated = 1.
+        Backward compatible with old databases (gracefully handles missing data).
+        """
+        with self._get_connection() as conn:
+            # First try to find by TMDB ID (most reliable)
+            if tmdb_id:
+                cursor = conn.execute('''
+                    SELECT is_rated FROM movies 
+                    WHERE tmdb_id = ? AND is_rated = 1
+                    LIMIT 1
+                ''', (tmdb_id,))
+                if cursor.fetchone():
+                    return True
+            
+            # Fallback: check by title + year
+            if title and year:
+                cursor = conn.execute('''
+                    SELECT is_rated FROM movies 
+                    WHERE title = ? AND year = ? AND is_rated = 1
+                    LIMIT 1
+                ''', (title, year))
+                if cursor.fetchone():
+                    return True
+            
+            return False
+
+    def get_previous_viewing_date(self, tmdb_id: str = None, title: str = None, year: int = None) -> Optional[str]:
+        """Get the previous viewing date for a movie (for rewatch display).
+        
+        Uses TMDB ID as primary identifier, falls back to title+year.
+        Returns ISO format date string if found, None otherwise.
+        """
+        with self._get_connection() as conn:
+            # First try to find by TMDB ID (most reliable)
+            if tmdb_id:
+                cursor = conn.execute('''
+                    SELECT last_viewed_at FROM movies 
+                    WHERE tmdb_id = ? AND is_rated = 1
+                    ORDER BY last_viewed_at DESC LIMIT 1
+                ''', (tmdb_id,))
+                row = cursor.fetchone()
+                if row and row['last_viewed_at']:
+                    return row['last_viewed_at']
+            
+            # Fallback: check by title + year
+            if title and year:
+                cursor = conn.execute('''
+                    SELECT last_viewed_at FROM movies 
+                    WHERE title = ? AND year = ? AND is_rated = 1
+                    ORDER BY last_viewed_at DESC LIMIT 1
+                ''', (title, year))
+                row = cursor.fetchone()
+                if row and row['last_viewed_at']:
+                    return row['last_viewed_at']
+            
+            return None
+
     def was_recently_notified(self, tmdb_id: str, title: str, year: int, last_viewed_at: datetime, threshold_seconds: int = 1800) -> bool:
         """Check if a notification was already sent for this movie (across all libraries).
         
@@ -415,7 +480,6 @@ class PlexDiscordBot(commands.Bot):
         super().__init__(command_prefix='!', intents=intents)
         self.plex_monitor = PlexMonitor()
         self.notify_channel = None
-
     async def setup_hook(self):
         """Initialize bot and Plex connection."""
         check_latest_version()
@@ -579,6 +643,10 @@ class PlexDiscordBot(commands.Bot):
                         (stored_last_viewed and (last_viewed - stored_last_viewed).total_seconds() > 7200)):
 
                         try:
+                            # Add previous viewing date for rewatch display
+                            if stored_last_viewed:
+                                movie_details['previous_viewed_at'] = stored_last_viewed.isoformat()
+                            
                             embed, file = await self.create_movie_embed(movie_details)
                             view = MovieButtons(
                                 movie_title=movie_details['title'],
@@ -635,6 +703,9 @@ class PlexDiscordBot(commands.Bot):
         try:
             logger.info(f"Bot started as: {self.user}")
             
+            # Set presence as Custom Status
+            await self.change_presence(activity=discord.CustomActivity(name="üé¨ Watching Plex"))
+            
             max_retries = 3
             retry_delay = 5
             for attempt in range(max_retries):
diff --git a/src/utils.py b/src/utils.py
index 18e7dff..eb3821d 100644
--- a/src/utils.py
+++ b/src/utils.py
@@ -7,6 +7,9 @@ from datetime import datetime
 from typing import Dict, Tuple, Optional
 import json
 
+# Import branding constants from main module
+from plex_bot import PLEX_LOGO, LETTERBOXD_LOGO, EMBED_AUTHOR_NAME, EMBED_FOOTER_TEXT
+
 async def create_movie_embed(movie_details: Dict) -> Tuple[discord.Embed, Optional[discord.File]]:
     """Create a Discord embed and optional file for movie notification."""
     embed = discord.Embed(
@@ -26,18 +29,25 @@ async def create_movie_embed(movie_details: Dict) -> Tuple[discord.Embed, Option
     
     if movie_details.get('library'):
         embed.add_field(name="üìö Library", value=movie_details['library'], inline=True)
-
-    if movie_details['view_count'] > 1 and movie_details['last_viewed_at']:
+    else:
+        embed.add_field(name="\u200b", value="\u200b", inline=True)  # Empty field for alignment
+    
+    # If rewatch: View Count in same row as Library, Last Viewed (previous date) in next row
+    if movie_details['view_count'] > 1 and movie_details.get('previous_viewed_at'):
+        embed.add_field(name="üìä View Count", value=str(movie_details['view_count']), inline=True)
         embed.add_field(
             name="üëÄ Last Viewed",
-            value=datetime.fromisoformat(movie_details['last_viewed_at']).strftime('%d.%m.%Y %H:%M'),
+            value=datetime.fromisoformat(movie_details['previous_viewed_at']).strftime('%d.%m.%Y %H:%M'),
             inline=True
         )
-        embed.add_field(name="üìä View Count", value=str(movie_details['view_count']), inline=True)
+        embed.add_field(name="\u200b", value="\u200b", inline=True)  # Empty field for alignment
+        embed.add_field(name="\u200b", value="\u200b", inline=True)  # Empty field for alignment
+    else:
+        embed.add_field(name="\u200b", value="\u200b", inline=True)  # Empty field for alignment
     
-    embed.set_author(name="Plex Movie Notification üé¨", icon_url="https://i.imgur.com/AdmDnsP.png")
-    embed.set_thumbnail(url="https://i.imgur.com/AdmDnsP.png")
-    embed.set_footer(text="Watched", icon_url="https://i.imgur.com/AdmDnsP.png")
+    embed.set_author(name=EMBED_AUTHOR_NAME, icon_url=PLEX_LOGO)
+    embed.set_thumbnail(url=PLEX_LOGO)
+    embed.set_footer(text=EMBED_FOOTER_TEXT, icon_url=PLEX_LOGO)
     
     file = None
     if movie_details.get('thumb'):
diff --git a/src/views.py b/src/views.py
index ae65a31..7599363 100644
--- a/src/views.py
+++ b/src/views.py
@@ -1,5 +1,7 @@
+# src/views.py
 import discord
-from discord.ui import Select, View
+from discord.ui import Button, View, Modal, TextInput, Select, Label
+from discord import TextStyle, SelectOption
 import logging
 from datetime import datetime
 import requests
@@ -7,10 +9,79 @@ from letterboxd_integration import login, get_film_id_selenium, save_diary_entry
 
 logger = logging.getLogger('PlexBot')
 
-class MovieButtons(View):
-    """Interactive buttons for rating movies on Letterboxd."""
-    def __init__(self, movie_title: str, movie_year: int, original_title: str = None, last_viewed_at: str = None, tmdb_id: str = None, bot=None, rating_key: str = None):
-        super().__init__(timeout=None)
+
+class DiaryEntryModal(Modal, title='Letterboxd Diary Entry'):
+    """Modal for creating a Letterboxd diary entry with extended options."""
+    
+    # Rating dropdown (required) - 0.5 to 5.0 stars with real star emojis
+    rating = Label(
+        text='‚≠ê Rating',
+        description='Select your rating for this film.',
+        component=Select(
+            placeholder='Choose a rating...',
+            options=[
+                SelectOption(label=f"{'‚≠ê' * int(r)} {'¬Ω' if r % 1 else ''}", value=str(r), description=f'{r} stars')
+                for r in [round(i * 0.5, 1) for i in range(1, 11)]
+            ],
+        ),
+    )
+    
+    # Rewatch dropdown (optional) - First Watch is default
+    rewatch = Label(
+        text='üîÑ Rewatch?',
+        description='Is this a rewatch?',
+        component=Select(
+            placeholder='First watch or rewatch?',
+            options=[
+                SelectOption(label='üé¨ First Watch', value='no', description='This is my first time watching', default=True),
+                SelectOption(label='üîÑ Rewatch', value='yes', description='I have seen this before'),
+            ],
+        ),
+    )
+    
+    # Liked dropdown (optional) - No is default
+    liked = Label(
+        text='‚ù§Ô∏è Liked?',
+        description='Did you love this film?',
+        component=Select(
+            placeholder='Did you like it?',
+            options=[
+                SelectOption(label='No', value='no', default=True),
+                SelectOption(label='Liked ‚ù§Ô∏è', value='yes', description='Add to your liked films'),
+            ],
+        ),
+    )
+    
+    # Tags (optional)
+    tags = Label(
+        text='üè∑Ô∏è Tags',
+        description='Add tags to categorize your viewing (optional).',
+        component=TextInput(
+            style=TextStyle.short,
+            placeholder='horror, cinema, rewatched with friends',
+            max_length=200,
+            required=False,
+        ),
+    )
+    
+    # Review (optional)
+    review = Label(
+        text='üìù Review',
+        description='Write your thoughts about the film (optional).',
+        component=TextInput(
+            style=TextStyle.paragraph,
+            placeholder='What did you think of the film?',
+            max_length=1000,
+            required=False,
+        ),
+    )
+    
+    def __init__(self, movie_title: str, movie_year: int, original_title: str = None, 
+                 last_viewed_at: str = None, tmdb_id: str = None, bot=None, 
+                 rating_key: str = None, is_rewatch: bool = False,
+                 parent_view=None, original_message=None):
+        super().__init__()
+        
         self.movie_title = movie_title
         self.movie_year = movie_year
         self.original_title = original_title or movie_title
@@ -18,54 +89,85 @@ class MovieButtons(View):
         self.tmdb_id = tmdb_id
         self.bot = bot
         self.rating_key = rating_key
-
-        rating_options = [
-            discord.SelectOption(label=f"{rating} ‚òÖ", value=str(rating))
-            for rating in [round(i * 0.5, 1) for i in range(1, 11)]
-        ]
-        self.rating_select = Select(
-            custom_id=f"rate_movie_{movie_title}_{movie_year}_{last_viewed_at or 'latest'}",
-            placeholder="Rate this movie",
-            min_values=1,
-            max_values=1,
-            options=rating_options
-        )
-        self.rating_select.callback = self.rating_callback
-        self.add_item(self.rating_select)
-
-    async def rating_callback(self, interaction: discord.Interaction):
-        """Handle rating selection and update Letterboxd."""
-        rating = float(interaction.data['values'][0])
+        self.parent_view = parent_view
+        self.original_message = original_message
+        
+        # Update modal title with movie name
+        self.title = f'Log: {movie_title[:35]}{"..." if len(movie_title) > 35 else ""}'
+        
+        # Pre-select rewatch if detected
+        if is_rewatch:
+            assert isinstance(self.rewatch.component, Select)
+            self.rewatch.component.options = [
+                SelectOption(label='üé¨ First Watch', value='no', description='This is my first time watching'),
+                SelectOption(label='üîÑ Rewatch', value='yes', description='I have seen this before', default=True),
+            ]
+    
+    async def on_submit(self, interaction: discord.Interaction):
+        """Handle modal submission and log to Letterboxd."""
         await interaction.response.defer(ephemeral=True)
-
+        
         try:
+            # Extract values from components
+            assert isinstance(self.rating.component, Select)
+            assert isinstance(self.rewatch.component, Select)
+            assert isinstance(self.liked.component, Select)
+            assert isinstance(self.tags.component, TextInput)
+            assert isinstance(self.review.component, TextInput)
+            
+            rating = float(self.rating.component.values[0])
+            is_rewatch = self.rewatch.component.values[0] == 'yes'
+            is_liked = self.liked.component.values[0] == 'yes'
+            tags_text = self.tags.component.value.strip() if self.tags.component.value else ""
+            review_text = self.review.component.value.strip() if self.review.component.value else ""
+            
+            # Log to Letterboxd
             session = requests.Session()
             session.headers.update({
                 "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/133.0.0.0 Safari/537.36",
                 "Referer": "https://letterboxd.com/",
             })
             csrf_token = login(session)
-            film_id = get_film_id_selenium(session, self.movie_title, self.movie_year, self.original_title, tmdb_id=self.tmdb_id)
+            film_id = get_film_id_selenium(
+                session, self.movie_title, self.movie_year, 
+                self.original_title, tmdb_id=self.tmdb_id
+            )
             if not film_id:
                 raise ValueError(f"Could not find film ID for '{self.original_title}' ({self.movie_year})")
-            save_diary_entry(session, csrf_token, film_id, rating, viewing_date=self.last_viewed_at)
-
-            viewed_at_display = self.last_viewed_at
-            viewed_at_dt = datetime.fromisoformat(viewed_at_display) if viewed_at_display else datetime.now()
-
-            self.rating_select.disabled = True
-            self.rating_select.placeholder = f"Rated {rating} ‚òÖ for {viewed_at_dt.strftime('%d.%m.%Y %H:%M')}"
+            
+            save_diary_entry(
+                session, csrf_token, film_id, rating,
+                viewing_date=self.last_viewed_at,
+                rewatch=is_rewatch,
+                liked=is_liked,
+                tags=tags_text,
+                review=review_text
+            )
+            
+            # Build success message (matching original format)
+            viewed_at_dt = datetime.fromisoformat(self.last_viewed_at) if self.last_viewed_at else datetime.now()
+            
             embed = discord.Embed(
                 title="Rating Successful!",
                 description=f"**{self.movie_title} ({self.movie_year})** rated **{rating} ‚òÖ** on Letterboxd.",
                 color=discord.Color.green(),
                 timestamp=viewed_at_dt
             )
-
             embed.set_author(name="Letterboxd Rating", icon_url="https://i.imgur.com/0Yd2L4i.png")
+            
             await interaction.followup.send(embed=embed, ephemeral=True)
-            await interaction.message.edit(view=self)
-
+            
+            # Disable the button after successful submission (matching original format)
+            if self.parent_view and self.original_message:
+                try:
+                    self.parent_view.diary_button.disabled = True
+                    self.parent_view.diary_button.label = f"Rated {rating} ‚òÖ for {viewed_at_dt.strftime('%d.%m.%Y %H:%M')}"
+                    self.parent_view.diary_button.style = discord.ButtonStyle.secondary
+                    await self.original_message.edit(view=self.parent_view)
+                except Exception as e:
+                    logger.warning(f"Could not disable button: {str(e)}")
+            
+            # Mark as rated in database
             if self.bot and self.bot.plex_monitor and self.rating_key:
                 try:
                     with self.bot.plex_monitor.db._get_connection() as conn:
@@ -74,14 +176,72 @@ class MovieButtons(View):
                         logger.info(f"Marked {self.movie_title} ({self.movie_year}) as rated in database")
                 except Exception as e:
                     logger.error(f"Failed to update rating status in database: {str(e)}")
-
+            
         except Exception as e:
-            logger.error(f"Failed to rate movie on Letterboxd: {str(e)}")
+            logger.error(f"Failed to log movie on Letterboxd: {str(e)}")
             embed = discord.Embed(
-                title="Rating Failed!",
-                description=f"Error: {str(e)[:200]}{'...' if len(str(e)) > 200 else ''}",
+                title="‚ùå Diary Entry Failed!",
+                description=f"Error: {str(e)[:300]}{'...' if len(str(e)) > 300 else ''}",
                 color=discord.Color.red(),
                 timestamp=datetime.now()
             )
             embed.set_author(name="Letterboxd Error", icon_url="https://i.imgur.com/0Yd2L4i.png")
-            await interaction.followup.send(embed=embed, ephemeral=True)
\ No newline at end of file
+            await interaction.followup.send(embed=embed, ephemeral=True)
+    
+    async def on_error(self, interaction: discord.Interaction, error: Exception) -> None:
+        logger.error(f"Modal error: {error}")
+        await interaction.response.send_message('An error occurred while processing your diary entry.', ephemeral=True)
+
+
+class MovieButtons(View):
+    """Interactive button for logging movies on Letterboxd."""
+    
+    def __init__(self, movie_title: str, movie_year: int, original_title: str = None, 
+                 last_viewed_at: str = None, tmdb_id: str = None, bot=None, rating_key: str = None):
+        super().__init__(timeout=None)
+        self.movie_title = movie_title
+        self.movie_year = movie_year
+        self.original_title = original_title or movie_title
+        self.last_viewed_at = last_viewed_at
+        self.tmdb_id = tmdb_id
+        self.bot = bot
+        self.rating_key = rating_key
+        
+        # Create the diary entry button
+        self.diary_button = Button(
+            label="üìù Diary Entry",
+            style=discord.ButtonStyle.primary,
+            custom_id=f"diary_entry_{movie_title}_{movie_year}_{last_viewed_at or 'latest'}"
+        )
+        self.diary_button.callback = self.diary_button_callback
+        self.add_item(self.diary_button)
+    
+    async def diary_button_callback(self, interaction: discord.Interaction):
+        """Open the diary entry modal when button is clicked."""
+        # Check if this is a rewatch
+        is_rewatch = False
+        if self.bot and self.bot.plex_monitor:
+            try:
+                is_rewatch = self.bot.plex_monitor.db.was_previously_watched(
+                    tmdb_id=self.tmdb_id,
+                    title=self.movie_title,
+                    year=self.movie_year
+                )
+                if is_rewatch:
+                    logger.info(f"Detected rewatch for {self.movie_title} ({self.movie_year})")
+            except Exception as e:
+                logger.warning(f"Could not check rewatch status: {str(e)}")
+        
+        modal = DiaryEntryModal(
+            movie_title=self.movie_title,
+            movie_year=self.movie_year,
+            original_title=self.original_title,
+            last_viewed_at=self.last_viewed_at,
+            tmdb_id=self.tmdb_id,
+            bot=self.bot,
+            rating_key=self.rating_key,
+            is_rewatch=is_rewatch,
+            parent_view=self,
+            original_message=interaction.message
+        )
+        await interaction.response.send_modal(modal)
\ No newline at end of file
